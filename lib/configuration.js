/** 
 * Функция configuration
 * 
 * Формирует скрытый внутренний объект с конфигурационными параметрами и 
 * возвращает get-функцию доступа к конфигурационным параметрам.
 * 
 * @param defaultParameters - объект с параметрами по умолчанию
 * @returns возвращает get-функцию доступа к конфигурационным параметрам
 * 
 * @autor Алексей Баранов
 * @version 1.0
 * 
 * Политика формирования и использования конфигурации приложения:
 * --------------------------------------------------------------
 * 
 *  1. Объект с конфигурационными параметрами формируется при старте программы
 *     и в дальнейшем при работе программы не меняется. Чтобы изменить 
 *     конфигурационные параметры необходимо остановить программу и затем
 *     запустить её заново с новыми параметрами.
 * 
 *  2. Все параметры, необходимые для работы программы, содержатся в едином
 *     месте, а именно во внутреннем скрытом объекте сформированном данной
 *     (настоящей) функцией и должны браться только из этого сформированного
 *     объекта с помощью функции-геттера, возвращаемой данной функцией.
 * 
 *  3. Объект с конфигурационными параметрами формируется из нескольких 
 *     источников, а именно:
 *     - из объекта с параметрами по умолчанию (наименьший приоритет);
 *     - из одного или нескольких конфигурационных файлов;
 *     - из установленных переменных окружения;
 *     - из командной строки (наивысший приоритет).
 * 
 *  4. Могут быть загружены конфигурационные файлы в форматах:
 *     - TOML (расширение файла .toml, .ini)
 *       Примечание:
 *       Не существует стандарта формата ini-файлов, однако простые ini-файлы
 *       схожи по формату с toml-файлами.
 *       
 *  5. Управление загрузкой информации осуществляется с помощью специальных
 *     управляющих параметров. Эти управляющие параметры могут содержаться
 *     как в объекте с параметрами по умолчанию, так и в конфигурационных
 *     файлах.
 *     Управляющие параметры:
 *     - configFile: Задаёт дополнительный конфигурационный файл, или массив
 *                   дополнительных конфигурационных файлов, которые необходимо
 *                   будет загрузить. Файл может быть задан объектом или
 *                   строкой.
 * 
 *                   Задание объектом: 
 *                   configFile: {fileName: 'config.ini',
 *                                format: 'toml'}
 *                   При задании имени файла с помощью объекта требуется
 *                   точно задать имя файла и формат файла, при этом имя
 *                   файла может иметь любое расширение, а так же может
 *                   вовсе не иметь расширения. Формат должен быть задан
 *                   из списка поддерживаемых и именно указанный формат
 *                   будет использован для синтаксического разбора файла.
 *                   Например:
 *                   configFile: {fileName: 'conf.txt', fileFormat: 'toml'}
 * 
 *                   Задание строкой:
 *                   configFile: 'config.ini'
 *                   или
 *                   configFile: 'config'
 *                   При задании имени файла с помощью строки, формат файла
 *                   определяется по расширению файла, если же расширение
 *                   не указано, программа будет искать файл самостоятельно
 *                   добавляя расширение в следующем порядке:
 *                     toml, ini.
 *                   То есть, программа сначала проверит наличие файла
 *                   config.toml и если такой файл существует, то загрузит
 *                   его, если же программа файл не найдёт, то она проверит
 *                   наличие файла config.ini и т. д.
 * 
 *                   Важно заметить, что загружаемые конфигурационные файлы
 *                   также могут содержать параметр configFile и,
 *                   следовательно, могут инициировать загрузку других
 *                   конфигурационных файлов, что иногда бывает полезно.
 * 
 *                   В случае, если в процессе обработки информации встречаются
 *                   дополнительные инструкции configFile, то процесс обработки
 *                   информации продолжается, а инструкции по загрузке
 *                   дополнительных файлов ставятся в очередь на загрузку в
 *                   порядке поступления.
 * 
 *                   После окончания обработки файла имя файла заносится в 
 *                   список обработанных файлов. Далее если в очереди на
 *                   загрузку есть другие файлы, то выбирается на обработку
 *                   следующий файл из очереди. Перед обработкой проверяется
 *                   содержится ли файл в списке обработанных. Если файл уже
 *                   был загружен ранее, то обработка данного файла отменяется.
 *                   Таким образом предотвращается циклическая загрузка одних
 *                   и тех же файлов.
 * 
 *                   
 *                   
 * 
 * 
 * 
 *  4. На первом шаге в объект конфигурации копируются параметры из объекта
 *     с параметрами по умолчанию.
 * 
 *  5. На втором шаге определяется имя конфигурационного файла и если файл с
 *     таким именем существует, то значения из конфигурационного файла
 *     затирают значения по умолчанию в объекте конфигурации. Если в объекте
 *     конфигурации значения параметра, прочитанного из файла конфигурации,
 *     нет, то значение параметра из 
 *     конфигурационного файла игнорируются (неизвестный параметр). Имя
 *     конфигурационного файла берётся из параметра по умолчанию
 *     configurationFileName. (На данный момент не реализовано: если имя файла
 *     конфигурации задано в командной строке, то чтение конфигурации будет
 *     производиться из этого файла.) Если имя не задано (т. е. не является
 *     строкой) или указанный в параметре файл не существует, то данный шаг
 *     игнорируется. Так же, если при чтении файла происходит ошибка или ошибка
 *     возникает при парсинге файла, то данный шаг тоже игнорируется. Программа
 *     не снимается и продолжает работу. (На данный момент для
 *     конфигурационного файла поддерживается только формат TOML.)
 * 
 *  6. На третьем шаге (на данный момент не реализовано) значения, полученные 
 *     из командной строки затирают текущие параметры конфигурации.
 * 
 *  7. На четвёртом шаге параметры из переменных окружения затирают текущие 
 *     значения в объекте параметров конфигурации. Параметры, заданные в 
 *     переменных окружения, имеют наивысший приоритет.
*/
function configuration(defaultParameters = {configFile : 'config'}) {




  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  const fileQueue = new ConfigFileQueue()

  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


  

  // создаём внутренний объект конфигурации
  let config = Object.create(null)

  let configFiles = [] // массив, в котором будут храниться имена
                       // файлов, которые необходимо загрузить

  let processed = Object.create(null) // список обработанных файлов


  // копируем во внутренний объект параметры по умолчанию
  Object.assign(config, defaultParameters)

  if ('configFile' in config) {
    // В объекте конфигурации есть свойство configFile
    // производим загрузку из конфигурационных файлов

    let configFile = config.configFile  // Извлекаем управляющий параметр
    delete config.configFile            // и удаляем из объекта
    configFiles = configFiles.concat(configFile)  // Добавляем файлы в список

    while (configFiles.length > 0) {
      readConfigFiles()  // считываем конфигурационный файл
    }
  }

  //    - из установленных переменных окружения;

  //    - из командной строки (наивысший приоритет).

  return getConfigParameter // Возвращаем get-функцию доступа к параметрам





  

  /** 
   * Функция readConfigFiles
   * 
   * Функция считывает конфигурационный файл.
   * 
  */
  function readConfigFiles() {

    let file = configFiles.shift()  // извлекаем первый элемент из очереди

    let fileName = ''
    let fileFormat = ''

    if (typeof file === 'object') {
      // конфигурационный файл задан объектом
      fileName = file.fileName
      fileFormat = file.fileFormat
    } else if (typeof file === 'string') {
      // конфигурационный файл задан объектом

      // Проверяем, есть ли у файла расширение
      let pos = file.lastIndexOf('.')
      if (pos > 0) {
        // нашли расширение


      } else {
        // расширения нет
      }

      
    } else {
      // некорректное задание конфигурационного файла
      throw 'readConfigFiles: Некорректное задание конфигурационного файла'
    }


  }



  

  /** 
   * Функция getConfigParameter
   * 
   * Функция доступа к конфигурационным параметрам.
   * 
   * @param parameter - строка с именем запрашиваемого параметра
   * @returns В общем случае возвращает запрашиваемый параметр.
   *          - В случае, если запрашиваемый параметр - объект, то
   *            возвращается копия объекта, чтобы исключить возможность
   *            изменения конфигурации.
   *          - В случае, если запрашиваемого параметра нет в объекте
   *            конфигурации, то возвращается undefined.
   *          - В случае, если в качестве имени запрашиваемого параметра
   *            передана пустая строка или строка из нескольких пробелов 
   *            или undefined, то возвращается копия всего объекта с 
   *            конфигурационными параметрами.
   *          - В случае, если в качестве имени запрашиваемого параметра
   *            передана не строка, то возвращается undefined.
  */
 function getConfigParameter(parameter = '') {

    if (typeof parameter !== 'string') {
      // Если в качестве имени параметра передана не строка, то
      // возвращаем undefined
      return undefined
    }

    // В качестве имени параметра передана строка

    parameter = parameter.trim()        // Убираем возможные пробелы

    if (parameter === '') {
      // Если в качестве имени параметра, была передана пустая строка
      // или строка пробелов или undefined или параметр не был задан
      // то возвращаем копию всего объекта с параметрами

      let result = Object.create(null)  // создаём новый пустой объект
      Object.assign(result, config)     // копируем в него объект параметров
      return result                     // возвращаем копию объекта параметров
    }

    // В качестве имени параметра передана не пустая строка

    let result = getParameterByName(parameter)  // Ищем параметр

    if (! (typeof result === 'object' || typeof result === 'function')) {
      // Найденный параметр - не объект => возвращаем его
      return result
    }

    // Найденный параметр - объект => создаём его копию и возвращаем копию

    let objCopy  = Object.create(null)  // создаём новый пустой объект
    Object.assign(objCopy, result)      // копируем в него найденный параметр
    return objCopy                      // возвращаем копию
  }


 /** 
   * Функция getParameterByName
   * 
   * Поиск параметра по имени.
   * 
   * @param parameter - строка с именем параметра (обязательный параметр).
   * @returns Возвращает найденный параметр или undefined в противном
   *          случае.
  */
   function getParameterByName(parameter) {

    if (parameter in config) {
      // Запрашиваемый параметр есть в объекте конфигурации
      return config[parameter]  // Извлекаем и возвращаем параметр
    }

    // Запрашиваемого параметра нет в объекте конфигурации,
    // проверяем, может быть запрошен параметр подобъекта

    if (! parameter.indexOf('.')) {
      // Запрашиваемого параметра нет в объекте конфигурации и
      // в строке параметра нет точки, следовательно, запрошен не подобъект
      //   => возвращаем undefined
      return undefined
    }

    // Запрошен параметр подобъекта

    let arr = parameter.split('.')  // Получаем массив подобъектов

    // Перебираем подобъекты и ищем необходимый параметр
    let subObj = config       // инициализируем подобъект, в котором будем
                              // искать параметр
    arr.forEach(searchParameter => {
      searchParameter = searchParameter.trim()  // убираем пробелы
      if (! searchParameter in subObj) {        // ищем 
        // параметр в подобъекте не найден => возвращаем undefined
        return undefined
      }

      // нашли параметр => извлекаем подобъект
      subObj = subObj[searchParameter]
    });

    // Прошли по цепочке подобъектов, нашли всё, значит в subObj
    // находится искомое значение необходимого нам подпараметра
    //   => возвращаем его.
    return subObj
  }
}
module.exports = configuration